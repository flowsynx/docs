"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[778],{3211:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"concepts/source-agnostic-processing","title":"Source-Agnostic Processing","description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments.","source":"@site/docs/concepts/source-agnostic-processing.mdx","sourceDirName":"concepts","slug":"/concepts/source-agnostic-processing","permalink":"/docs/concepts/source-agnostic-processing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},"sidebar":"docSidebar","previous":{"title":"Unified Data Abstraction Layer","permalink":"/docs/concepts/unified-data-abstraction-layer"},"next":{"title":"Trigger-Based Execution","permalink":"/docs/concepts/trigger-based-execution"}}');var o=s(4848),r=s(8453);const t={sidebar_position:6,description:"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},a="Source-Agnostic Processing",c={},l=[];function d(e){const n={h1:"h1",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"source-agnostic-processing",children:"Source-Agnostic Processing"})}),"\n",(0,o.jsxs)(n.p,{children:["Once the data is loaded into FlowSynx\u2019s ",(0,o.jsx)(n.strong,{children:"Unified Data Abstraction Layer (UDAL)"})," model, all downstream processing\nplugins (e.g., CSV, ZipCompresor/Decompresor, DatabaseWriter) can operate ",(0,o.jsx)(n.strong,{children:"uniformly and interchangeably"}),",\nregardless of the original data source or protocol."]}),"\n",(0,o.jsxs)(n.p,{children:["This abstraction ensures a ",(0,o.jsx)(n.strong,{children:"consistent data representation"}),"\u2014so plugins no longer need to handle source-specific\nlogic or connection details. Instead, each plugin works purely on the normalized UDAL objects, enabling a fully\nmodular and composable data workflow."]}),"\n",(0,o.jsx)(n.p,{children:"Whether the input originated from:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.strong,{children:"local file"})," (e.g., CSV, JSON, XML)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cloud object storage"})," such as Azure Blob Storage, Azure Data Lake, or Amazon S3"]}),"\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.strong,{children:"remote REST API"})," endpoint (JSON, XML, or custom schema)"]}),"\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.strong,{children:"database query result"})," (via SQL or ORM adapters)"]}),"\n",(0,o.jsxs)(n.li,{children:["Or even a ",(0,o.jsx)(n.strong,{children:"streaming or message-based source"})," (Kafka, Event Hub, RabbitMQ)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"\u2026the behavior and execution flow remain identical from the plugin\u2019s perspective."}),"\n",(0,o.jsx)(n.p,{children:"This design provides several key advantages:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Uniformity:"})," All plugins interact with a consistent in-memory model, reducing conditional logic and source coupling."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reusability:"})," The same transformation and enrichment logic can be reused across multiple data ingestion pipelines."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Extensibility:"})," New data sources can be integrated simply by adding a new source adapter that maps incoming data to the UDAL schema\u2014no changes needed to existing processing logic."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scalability:"})," Workflows can scale horizontally without worrying about differences in storage or access patterns."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Ultimately, this ",(0,o.jsx)(n.strong,{children:"source-agnostic"})," approach makes FlowSynx\u2019s processing layer truly modular, future-proof, and cloud-neutral\u2014enabling seamless integration across diverse enterprise data ecosystems."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const o={},r=i.createContext(o);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);