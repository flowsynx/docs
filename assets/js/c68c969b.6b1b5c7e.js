"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[9871],{8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},8948:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"concepts/plugin-based-architecture","title":"Plugin-Based Extensibility","description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments.","source":"@site/docs/concepts/plugin-based-architecture.mdx","sourceDirName":"concepts","slug":"/concepts/plugin-based-architecture","permalink":"/docs/concepts/plugin-based-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},"sidebar":"docSidebar","previous":{"title":"Concepts","permalink":"/docs/concepts"},"next":{"title":"Directed Acyclic Graphs (DAG)","permalink":"/docs/concepts/directed-acyclic-graphs"}}');var o=i(4848),s=i(8453);const r={sidebar_position:1,description:"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},a="Plugin-Based Extensibility",c={},l=[];function d(e){const n={h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"plugin-based-extensibility",children:"Plugin-Based Extensibility"})}),"\n",(0,o.jsx)(n.p,{children:"A plugin-based architecture is a software design pattern that emphasizes modularity and extensibility by allowing\nindependent components (plugins) to be dynamically loaded and integrated into the core application. In FlowSynx,\nthis architecture is central to the system's flexibility\u2014each plugin encapsulates specific logic or capabilities,\nsuch as connecting to a cloud provider, processing a file, transforming data, or triggering a workflow. The core\norchestration engine remains lightweight and generic, while plugins extend its functionality in a composable,\nloosely-coupled way."}),"\n",(0,o.jsx)(n.p,{children:"This design allows teams to develop and deploy custom features without altering or recompiling the core system.\nPlugins can be versioned, isolated, and even sandboxed for security. FlowSynx supports runtime discovery and\nloading of plugins, enabling dynamic deployment and upgrades. Combined with plugin licensing, dependency injection,\nand configuration isolation, this architecture enables a highly scalable ecosystem where users can tailor the\nplatform to their exact workflow needs\u2014whether that means building proprietary integrations, leveraging community-contributed\nextensions, or enforcing strict organizational controls."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);