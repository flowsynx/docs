"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[1117],{3425:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"concepts/retry-policies-error-handling","title":"Retry Policies & Error Handling","description":"Learn how FlowSynx uses powerful retry policies and configurable error-handling strategies to ensure resilient, reliable, and fault-tolerant workflow execution in dynamic and unpredictable environments.","source":"@site/versioned_docs/version-1.2.x/concepts/retry-policies-error-handling.mdx","sourceDirName":"concepts","slug":"/concepts/retry-policies-error-handling","permalink":"/docs/1.2.x/concepts/retry-policies-error-handling","draft":false,"unlisted":false,"tags":[],"version":"1.2.x","lastUpdatedAt":1769035982000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"description":"Learn how FlowSynx uses powerful retry policies and configurable error-handling strategies to ensure resilient, reliable, and fault-tolerant workflow execution in dynamic and unpredictable environments."},"sidebar":"docSidebar","previous":{"title":"JSON Schema Validation","permalink":"/docs/1.2.x/concepts/json-schema-validation"},"next":{"title":"Unified Data Abstraction Layer","permalink":"/docs/1.2.x/concepts/unified-data-abstraction-layer"}}');var t=i(4848),a=i(8453);const s={sidebar_position:4,description:"Learn how FlowSynx uses powerful retry policies and configurable error-handling strategies to ensure resilient, reliable, and fault-tolerant workflow execution in dynamic and unpredictable environments."},l="Retry Policies & Error Handling",o={},d=[{value:"Why Retry Policies Matter",id:"why-retry-policies-matter",level:2},{value:"Retry Strategies",id:"retry-strategies",level:2},{value:"1. Fixed Delay",id:"1-fixed-delay",level:3},{value:"Example:",id:"example",level:4},{value:"2. Linear Backoff",id:"2-linear-backoff",level:3},{value:"Example:",id:"example-1",level:4},{value:"3. Exponential Backoff",id:"3-exponential-backoff",level:3},{value:"Example:",id:"example-2",level:4},{value:"4. Jitter",id:"4-jitter",level:3},{value:"Example:",id:"example-3",level:4},{value:"Retry Policy Configuration",id:"retry-policy-configuration",level:2},{value:"Configuration Fields",id:"configuration-fields",level:4},{value:"Error Handling in FlowSynx",id:"error-handling-in-flowsynx",level:2},{value:"1. Retry",id:"1-retry",level:3},{value:"2. Skip",id:"2-skip",level:3},{value:"Use cases:",id:"use-cases",level:4},{value:"3. Abort",id:"3-abort",level:3},{value:"Use cases:",id:"use-cases-1",level:4},{value:"4. TriggerTask",id:"4-triggertask",level:3},{value:"Examples:",id:"examples",level:4}];function c(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"retry-policies--error-handling",children:"Retry Policies & Error Handling"})}),"\n",(0,t.jsx)(n.p,{children:"No matter how well-designed a workflow is, failures are inevitable\u2014network blips, unavailable APIs, temporary file locks,\nslow external services, and unexpected data conditions can all cause tasks to fail. What separates a reliable orchestration\nsystem from a fragile one is how effectively it responds to these failures."}),"\n",(0,t.jsx)(n.p,{children:"FlowSynx provides a powerful, flexible, and fully declarative framework for managing task failures through retry policies\nand error-handling mechanisms. Together, these features ensure that workflows remain resilient, self-healing, and capable of\nadapting to runtime conditions without requiring human intervention."}),"\n",(0,t.jsx)("img",{src:"/img/Retry-Policies-Error-Handling.jpg"}),"\n",(0,t.jsx)(n.h2,{id:"why-retry-policies-matter",children:"Why Retry Policies Matter"}),"\n",(0,t.jsx)(n.p,{children:"In distributed systems and integration-heavy environments, many failures are not permanent\u2014they are transient.\nA database might be briefly unavailable, an API may be momentarily overloaded, or a short-lived network failure\nmay interrupt a task. Retry policies give FlowSynx the ability to distinguish between transient and unrecoverable\nconditions and respond accordingly."}),"\n",(0,t.jsx)(n.p,{children:"Instead of immediately marking a task or workflow as failed, retry logic allows FlowSynx to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Attempt recovery automatically"}),"\n",(0,t.jsx)(n.li,{children:"Reduce the need for human operators to investigate temporary issues"}),"\n",(0,t.jsx)(n.li,{children:"Increase workflow reliability without additional complexity in user code"}),"\n",(0,t.jsx)(n.li,{children:"Adapt behavior based on task importance, latency tolerance, and failure patterns"}),"\n",(0,t.jsx)(n.li,{children:"Enforce consistent operational behavior across teams and environments"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Retry policies transform workflows from brittle pipelines into robust, fault-tolerant systems capable of gracefully\nhandling real-world conditions."}),"\n",(0,t.jsx)(n.h2,{id:"retry-strategies",children:"Retry Strategies"}),"\n",(0,t.jsx)(n.p,{children:"FlowSynx supports multiple retry strategies, each optimized for different operational scenarios.\nAll retry behavior is fully configurable per task, giving developers and operators fine-grained\ncontrol over execution behavior."}),"\n",(0,t.jsx)(n.h3,{id:"1-fixed-delay",children:"1. Fixed Delay"}),"\n",(0,t.jsxs)(n.p,{children:["Retries occur after a constant delay between attempts.",(0,t.jsx)(n.br,{}),"\n","Best suited for predictable, low-variance environments where a consistent cooldown is sufficient."]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Retry every 5 seconds regardless of the number of attempts."}),"\n",(0,t.jsx)(n.h3,{id:"2-linear-backoff",children:"2. Linear Backoff"}),"\n",(0,t.jsxs)(n.p,{children:["Delay increases linearly after each retry attempt.",(0,t.jsx)(n.br,{}),"\n","Useful when failures become less likely to resolve without additional cooldown time."]}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Retry after 5s, then 10s, then 15s\u2026"}),"\n",(0,t.jsx)(n.h3,{id:"3-exponential-backoff",children:"3. Exponential Backoff"}),"\n",(0,t.jsx)(n.p,{children:"Delay grows exponentially after each failure.\nIdeal for handling throttled APIs, rate-limited services, or cascading system overload."}),"\n",(0,t.jsx)(n.h4,{id:"example-2",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Retry after 2s, 4s, 8s, 16s\u2026"}),"\n",(0,t.jsx)(n.h3,{id:"4-jitter",children:"4. Jitter"}),"\n",(0,t.jsxs)(n.p,{children:["Adds randomness to delay intervals to prevent retry storms or synchronized failures, especially in distributed systems.",(0,t.jsx)(n.br,{}),"\n","Jitter can be combined with any strategy to avoid concurrent retry spikes."]}),"\n",(0,t.jsx)(n.h4,{id:"example-3",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"An exponential backoff of 8s \xb1 random jitter between 0\u20132s."}),"\n",(0,t.jsx)(n.h2,{id:"retry-policy-configuration",children:"Retry Policy Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Retry policies are defined declaratively inside task definitions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"retryPolicy": {\n   "backoffStrategy": "fixed",\n   "maxRetries": 3,\n   "initialDelay": 100000,\n   "maxDelay": 100000\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"configuration-fields",children:"Configuration Fields"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"backoffStrategy"})," \u2014 ",(0,t.jsx)(n.code,{children:"fixed"}),", ",(0,t.jsx)(n.code,{children:"linear"}),", ",(0,t.jsx)(n.code,{children:"exponential"}),", ",(0,t.jsx)(n.code,{children:"jitter"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"maxRetries"})," \u2014 Maximum number of attempts before the task is considered failed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"initialDelay"})," \u2014 Delay (ms) before the first retry"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"maxDelay"})," \u2014 Optional upper cap for backoff growth"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"jitter"})," \u2014 Optional randomized delay component"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If no retry policy is defined, FlowSynx defaults to zero retries\u2014failures propagate immediately."}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-in-flowsynx",children:"Error Handling in FlowSynx"}),"\n",(0,t.jsx)(n.p,{children:"While retry policies address transient issues, error-handling actions define what FlowSynx should do when retries are\nexhausted or when an error is considered unrecoverable."}),"\n",(0,t.jsx)(n.p,{children:"FlowSynx supports multiple post-failure behaviors that give developers control over workflow continuity and compensation logic."}),"\n",(0,t.jsx)(n.h3,{id:"1-retry",children:"1. Retry"}),"\n",(0,t.jsxs)(n.p,{children:["Re-executes the task according to the defined retry policy.",(0,t.jsx)(n.br,{}),"\n","This happens before any error-handling action is evaluated and is part of the standard failure pipeline."]}),"\n",(0,t.jsx)(n.h3,{id:"2-skip",children:"2. Skip"}),"\n",(0,t.jsxs)(n.p,{children:["Skips the failed task and continues workflow execution.",(0,t.jsx)(n.br,{}),"\n","Downstream tasks still execute, but dependencies receive a skipped status."]}),"\n",(0,t.jsx)(n.h4,{id:"use-cases",children:"Use cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Optional tasks"}),"\n",(0,t.jsx)(n.li,{children:"Side-effect-free steps"}),"\n",(0,t.jsx)(n.li,{children:"Best-effort enrichment workflows"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-abort",children:"3. Abort"}),"\n",(0,t.jsx)(n.p,{children:"Stops the entire workflow and marks it as failed."}),"\n",(0,t.jsx)(n.h4,{id:"use-cases-1",children:"Use cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Critical steps where partial results are unacceptable"}),"\n",(0,t.jsx)(n.li,{children:"Compliance or security-sensitive operations"}),"\n",(0,t.jsx)(n.li,{children:"Situations where continued execution would cause data corruption"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-triggertask",children:"4. TriggerTask"}),"\n",(0,t.jsx)(n.p,{children:"Executes a fallback or compensating task\u2014similar to a saga or compensating transaction step."}),"\n",(0,t.jsx)(n.h4,{id:"examples",children:"Examples:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cleanup of partially written data"}),"\n",(0,t.jsx)(n.li,{children:"Sending a notification to operators"}),"\n",(0,t.jsx)(n.li,{children:"Starting a backup workflow"}),"\n",(0,t.jsx)(n.li,{children:"Reverting changes performed by preceding tasks"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"TriggerTask allows workflows to implement corrective behavior and guarantees operational consistency even in failure cases."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"FlowSynx's retry policies and error-handling framework enable workflows to remain robust, self-healing, and highly\nreliable even in dynamic or distributed environments. By combining multiple backoff strategies, jitter, compensating\ntasks, and fine-grained control over failure behavior, FlowSynx delivers operational resilience without requiring\nadditional user code."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);