"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[9158],{4277:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"concepts/dependencies-execution-order","title":"Dependencies & Execution Order","description":"Understanding how FlowSynx manages task dependencies and execution order using DAG-based scheduling to ensure reliable, predictable, and optimized workflow execution.","source":"@site/docs/concepts/dependencies-execution-order.mdx","sourceDirName":"concepts","slug":"/concepts/dependencies-execution-order","permalink":"/docs/concepts/dependencies-execution-order","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1766577873000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"Understanding how FlowSynx manages task dependencies and execution order using DAG-based scheduling to ensure reliable, predictable, and optimized workflow execution."},"sidebar":"docSidebar","previous":{"title":"Directed Acyclic Graphs (DAG)","permalink":"/docs/concepts/directed-acyclic-graphs"},"next":{"title":"JSON Schema Validation","permalink":"/docs/concepts/json-schema-validation"}}');var l=i(4848),r=i(8453);const a={sidebar_position:3,description:"Understanding how FlowSynx manages task dependencies and execution order using DAG-based scheduling to ensure reliable, predictable, and optimized workflow execution."},t="Dependencies & Execution Order",c={},o=[{value:"The Role of Dependencies in Workflow Design",id:"the-role-of-dependencies-in-workflow-design",level:2},{value:"Basic Dependency Example",id:"basic-dependency-example",level:3},{value:"Validating Dependencies &amp; Detecting Structural Problems",id:"validating-dependencies--detecting-structural-problems",level:2},{value:"1. Duplicate Task Detection (O(n))",id:"1-duplicate-task-detection-on",level:3},{value:"Diagram",id:"diagram",level:4},{value:"2. Missing Dependencies / Missing Branch Targets (O(V + E))",id:"2-missing-dependencies--missing-branch-targets-ov--e",level:3},{value:"3. Cyclic Dependency Detection (Kahn\u2019s Algorithm) (O(V + E))",id:"3-cyclic-dependency-detection-kahns-algorithm-ov--e",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:4},{value:"Diagram \u2014 No Cycle",id:"diagram--no-cycle",level:4},{value:"Diagram \u2014 Cycle Exists",id:"diagram--cycle-exists",level:4},{value:"Dynamic Execution Planning in FlowSynx",id:"dynamic-execution-planning-in-flowsynx",level:2},{value:"Execution Flow Diagram",id:"execution-flow-diagram",level:3},{value:"Concurrency and Parallel Execution",id:"concurrency-and-parallel-execution",level:2},{value:"Parallelism Example",id:"parallelism-example",level:3},{value:"Dependency-Driven Reliability",id:"dependency-driven-reliability",level:2},{value:"Error Isolation Diagram",id:"error-isolation-diagram",level:3},{value:"Conditional Branching and Advanced Flows",id:"conditional-branching-and-advanced-flows",level:2},{value:"Scaling to Large Pipelines",id:"scaling-to-large-pipelines",level:2},{value:"Large Pipeline DAG",id:"large-pipeline-dag",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"dependencies--execution-order",children:"Dependencies & Execution Order"})}),"\n",(0,l.jsxs)(n.p,{children:["Workflow execution is not just about running tasks\u2014it's about running them ",(0,l.jsx)(n.strong,{children:"in the correct order"}),", ",(0,l.jsx)(n.strong,{children:"with the correct prerequisites"}),", and ",(0,l.jsx)(n.strong,{children:"at the correct moment"}),". In FlowSynx, this process is governed by a powerful dependency model rooted in Directed Acyclic Graphs (DAGs). Dependencies define the logical and temporal relationships between tasks, ensuring that each step executes exactly when it should and that the workflow behaves consistently, even as it grows in complexity."]}),"\n",(0,l.jsx)(n.h2,{id:"the-role-of-dependencies-in-workflow-design",children:"The Role of Dependencies in Workflow Design"}),"\n",(0,l.jsxs)(n.p,{children:["Dependencies specify which tasks must complete before another task can begin. In DAG terminology, these are represented as ",(0,l.jsx)(n.strong,{children:"directed edges"})," between nodes:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Parent / Upstream Task"})," \u2014 A prerequisite"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Child / Downstream Task"})," \u2014 A task that depends on one or more parents"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["A task ",(0,l.jsx)(n.em,{children:"cannot"})," start until all upstream dependencies have completed successfully."]}),"\n",(0,l.jsx)(n.h3,{id:"basic-dependency-example",children:"Basic Dependency Example"}),"\n",(0,l.jsx)("img",{src:"/img/Basic-Dependency-Example.jpg"}),"\n",(0,l.jsx)(n.h2,{id:"validating-dependencies--detecting-structural-problems",children:"Validating Dependencies & Detecting Structural Problems"}),"\n",(0,l.jsx)(n.p,{children:"To guarantee correctness before execution begins, FlowSynx automatically runs a series of structural validation checks. These checks ensure that the workflow is valid, executable, and free of ambiguous or inconsistent definitions."}),"\n",(0,l.jsx)(n.p,{children:"FlowSynx uses a combination of simple hash-based scans and a classic cycle-detection algorithm."}),"\n",(0,l.jsx)(n.h3,{id:"1-duplicate-task-detection-on",children:"1. Duplicate Task Detection (O(n))"}),"\n",(0,l.jsxs)(n.p,{children:["FlowSynx uses a ",(0,l.jsx)(n.strong,{children:"single-pass HashSet membership test"})," to ensure task names are unique:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"for each task:\n    if task.Name in hashset: DUPLICATE\n    else add to hashset\n"})}),"\n",(0,l.jsx)(n.h4,{id:"diagram",children:"Diagram"}),"\n",(0,l.jsx)("img",{src:"/img/Duplicate-Task-Detection.jpg"}),"\n",(0,l.jsx)(n.h3,{id:"2-missing-dependencies--missing-branch-targets-ov--e",children:"2. Missing Dependencies / Missing Branch Targets (O(V + E))"}),"\n",(0,l.jsx)(n.p,{children:"FlowSynx builds a HashSet of all defined task names and checks whether dependencies reference anything that doesn't exist."}),"\n",(0,l.jsx)("img",{src:"/img/Missing-Dependencies.jpg"}),"\n",(0,l.jsx)(n.h3,{id:"3-cyclic-dependency-detection-kahns-algorithm-ov--e",children:"3. Cyclic Dependency Detection (Kahn\u2019s Algorithm) (O(V + E))"}),"\n",(0,l.jsxs)(n.p,{children:["FlowSynx uses ",(0,l.jsx)(n.strong,{children:"Kahn\u2019s Algorithm"}),", a topological sort strategy, to detect cycles. Kahn\u2019s Algorithm is a classic method for detecting cycles in a directed graph (like a workflow DAG).\nIf the workflow has a cycle, you cannot topologically sort it, and that\u2019s exactly how the algorithm detects the problem."]}),"\n",(0,l.jsx)(n.h4,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Each task is a node (V)."}),"\n",(0,l.jsxs)(n.li,{children:["Each dependency is a directed edge (E): ",(0,l.jsx)(n.strong,{children:"A \u2192 B"})," means A must run before B."]}),"\n",(0,l.jsx)(n.li,{children:"We compute in-degree for each node:"}),"\n",(0,l.jsx)(n.li,{children:"How many tasks depend on this node?"}),"\n",(0,l.jsx)(n.li,{children:"Repeatedly remove nodes with in-degree = 0 (tasks with no unmet prerequisites)."}),"\n",(0,l.jsx)(n.li,{children:"Removing a node also removes its outgoing edges, lowering in-degrees of its neighbors."}),"\n",(0,l.jsx)(n.li,{children:"If there is a cycle, some nodes will never reach in-degree 0."}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"diagram--no-cycle",children:"Diagram \u2014 No Cycle"}),"\n",(0,l.jsx)("img",{src:"/img/DAG-NoCycle-Exists.jpg"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"in-degree:\nA:0, B:1, C:1\n\nQueue: [A]\nPop A \u2192 decrement B \u2192 B:0 \u2192 enqueue B\nPop B \u2192 decrement C \u2192 C:0 \u2192 enqueue C\nPop C \u2192 done\n\nProcessed = 3, Total = 3 \u2192 no cycle\n"})}),"\n",(0,l.jsx)(n.h4,{id:"diagram--cycle-exists",children:"Diagram \u2014 Cycle Exists"}),"\n",(0,l.jsx)("img",{src:"/img/DAG-Cycle-Exists.jpg"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"in-degree:\nA:1, B:1, C:1\n\nQueue: (empty)\n\nProcessed = 0 < 3 \u2192 cycle detected\n"})}),"\n",(0,l.jsx)(n.h2,{id:"dynamic-execution-planning-in-flowsynx",children:"Dynamic Execution Planning in FlowSynx"}),"\n",(0,l.jsx)(n.p,{children:"FlowSynx analyzes task dependencies and computes the execution plan dynamically."}),"\n",(0,l.jsx)(n.h3,{id:"execution-flow-diagram",children:"Execution Flow Diagram"}),"\n",(0,l.jsx)("img",{src:"/img/Execution-Flow-Diagram.jpg"}),"\n",(0,l.jsx)(n.h2,{id:"concurrency-and-parallel-execution",children:"Concurrency and Parallel Execution"}),"\n",(0,l.jsx)(n.p,{children:"DAGs allow tasks with no dependency relationship to run concurrently."}),"\n",(0,l.jsx)(n.h3,{id:"parallelism-example",children:"Parallelism Example"}),"\n",(0,l.jsx)("img",{src:"/img/Parallelism-Example.jpg"}),"\n",(0,l.jsx)(n.p,{children:"A and B run in parallel; C waits for both."}),"\n",(0,l.jsx)(n.h2,{id:"dependency-driven-reliability",children:"Dependency-Driven Reliability"}),"\n",(0,l.jsx)(n.h3,{id:"error-isolation-diagram",children:"Error Isolation Diagram"}),"\n",(0,l.jsx)("img",{src:"/img/Error-Isolation-Diagram.jpg"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"If [B] fails:\n   [C] blocked\n   [D] blocked\n   [E] blocked\n"})}),"\n",(0,l.jsx)(n.p,{children:"FlowSynx can isolate the branch containing failures without affecting unrelated parts of the workflow."}),"\n",(0,l.jsx)(n.h2,{id:"conditional-branching-and-advanced-flows",children:"Conditional Branching and Advanced Flows"}),"\n",(0,l.jsx)("img",{src:"/img/Conditional-Branching-Flow.jpg"}),"\n",(0,l.jsx)(n.h2,{id:"scaling-to-large-pipelines",children:"Scaling to Large Pipelines"}),"\n",(0,l.jsx)(n.h3,{id:"large-pipeline-dag",children:"Large Pipeline DAG"}),"\n",(0,l.jsx)("img",{src:"/img/Large-Pipeline-DAG.jpg"}),"\n",(0,l.jsx)(n.p,{children:"FlowSynx\u2019s dependency model enables:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Automated ordering"}),"\n",(0,l.jsx)(n.li,{children:"Fast topological sorting"}),"\n",(0,l.jsx)(n.li,{children:"Predictable state transitions"}),"\n",(0,l.jsx)(n.li,{children:"High concurrency"}),"\n",(0,l.jsx)(n.li,{children:"Fine-grained error localization"}),"\n",(0,l.jsx)(n.li,{children:"Improved debuggability through clear DAG visualization"}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsxs)(n.p,{children:["Proper dependency management is not just a feature of FlowSynx\u2014it is one of the core principles enabling powerful,\nreliable, and scalable workflow automation. By combining ",(0,l.jsx)(n.strong,{children:"hash-based validations"}),", ",(0,l.jsx)(n.strong,{children:"graph integrity checks"}),", and\n",(0,l.jsx)(n.strong,{children:"Kahn\u2019s Algorithm"}),", FlowSynx ensures that every workflow is structurally sound ",(0,l.jsx)(n.em,{children:"before a single task executes"}),". And\nthrough DAG-driven scheduling, FlowSynx guarantees that each workflow runs exactly as intended, regardless of complexity or scale."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var s=i(6540);const l={},r=s.createContext(l);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);