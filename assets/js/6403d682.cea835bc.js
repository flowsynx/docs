"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[1102],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var o=i(6540);const r={},t=o.createContext(r);function s(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(t.Provider,{value:n},e.children)}},9993:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"concepts/retry-policies-error-handling","title":"Retry Policies & Error Handling","description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments.","source":"@site/docs/concepts/retry-policies-error-handling.mdx","sourceDirName":"concepts","slug":"/concepts/retry-policies-error-handling","permalink":"/docs/concepts/retry-policies-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},"sidebar":"docSidebar","previous":{"title":"Dependencies & Execution Order","permalink":"/docs/concepts/dependencies-execution-order"},"next":{"title":"JSON Schema Validation","permalink":"/docs/concepts/json-schema-validation"}}');var r=i(4848),t=i(8453);const s={sidebar_position:3,description:"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},a="Retry Policies & Error Handling",c={},l=[];function d(e){const n={h1:"h1",header:"header",p:"p",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"retry-policies--error-handling",children:"Retry Policies & Error Handling"})}),"\n",(0,r.jsx)(n.p,{children:"Retry policies define how the system should respond to failures during task execution. In a robust workflow engine like\nFlowSynx, each task can have custom retry strategies\u2014such as fixed delays, exponential backoff, or limited retry\nattempts\u2014configured declaratively. This allows workflows to be resilient to transient failures (e.g., temporary network\nissues, slow third-party APIs) without manual intervention."}),"\n",(0,r.jsx)(n.p,{children:"Error handling complements retries by defining fallback behaviors, like alternative branches, alerts, manual approval\nsteps, or graceful workflow termination. FlowSynx supports conditional error paths, enabling workflows to recover or\nadapt when specific failures occur. Together, retry and error handling mechanisms reduce operational burden, increase\nsystem reliability, and ensure critical workflows complete successfully even in the face of unpredictable runtime conditions."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);