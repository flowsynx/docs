---
sidebar_position: 3
title: Expressions Syntax
description: FlowSynx expression system for dynamic access to variables, task outputs, nested data, arithmetic, conditionals, boolean logic, and functional aggregation.
---

# FlowSynx Expression Syntax

FlowSynx provides a powerful expression system for dynamically resolving **workflow variables**, **task outputs**, **nested properties**, **arithmetic**, **boolean logic**, **conditional (ternary) operations**, and **functional aggregations** at runtime.  
All expressions are evaluated by the `ExpressionParser`.

## Core Delimiter

Wrap any resolvable content in:
```
$[...]
```

If the entire value is a single `$[...]` block, the resolved object is returned directly (e.g. an array or JSON object). If embedded inside a larger string, the resolved value is converted to a string and concatenated.

## Data Sources

| Source | Syntax | Description |
| ------ | ------ | ----------- |
| Variables | `$[Variables('Key')]` | Workflow-level variable lookup (case-insensitive). |
| Outputs | `$[Outputs('TaskName')]` | Output of a previously executed task (case-insensitive). |

Keys with spaces or special characters should use single quotes: `$[Variables('My Custom Key')]`.

### Outputs as PluginContext

The [`Outputs`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fc%3A%2Fgithub%2Fflowsynx%2Fdocs%2Fdocs%2Freference%2Fflowsynx%2Fexpressions.mdx%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A25%2C%22character%22%3A2%7D%7D%5D%2C%2203b219c3-6667-4007-919c-1aa2e2101390%22%5D "Go to definition") object provides access to the following properties:

| Property         | Description                                                                 |
| ---------------- | --------------------------------------------------------------------------- |
| `Id`             | The unique identifier of the plugin context.                               |
| `SourceType`     | The type of source that generated the output.                               |
| `Format`         | The format of the output, if applicable.                                    |
| `Metadata`       | A dictionary containing metadata as key-value pairs.                       |
| `RawData`        | The raw binary data of the output, if available.                            |
| `Content`        | The string content of the output, if available.                             |
| `StructuredData` | A list of dictionaries representing structured data, if applicable.         |

Keys with spaces or special characters should use single quotes: `$[Variables('My Custom Key')]`.

#### Example

##### Accessing Metadata
You can retrieve specific metadata values using dot notation:

```
$[Outputs('TaskName').Metadata['Key']]
```

##### Accessing Content
To retrieve the content of the output:

```
$[Outputs('TaskName').Content]
```

##### Accessing Structured Data
You can traverse the StructuredData property to access specific elements:

```
$[Outputs('TaskName').StructuredData[0]['FieldName']]
```

##### Combining Properties
You can combine multiple properties in expressions:

```
$[Outputs('TaskName').Id + ' - ' + Outputs('TaskName').SourceType]
```

#### Notes on PluginContext
- Metadata keys are case-insensitive.
- RawData is a binary array and cannot be directly used in string concatenation. You may need to convert it to a string or process it separately.
- StructuredData is a list of dictionaries, allowing traversal and dynamic access to nested fields.

#### Updated Examples
Here are some updated examples reflecting the PluginContext structure:

```
$[Outputs('Task').Id]
$[Outputs('Task').Metadata['Category']]
$[Outputs('Task').StructuredData[0]['Name']]
$[Contains(Outputs('Task').Metadata, 'urgent')]
$[Outputs('Task').Content == 'success' ? 'completed' : 'retry']
```

#### Error Handling for PluginContext
- Accessing a non-existent property or key in Metadata or StructuredData will throw a FlowSynxException with the code ExpressionParserKeyNotFound.
- Ensure that RawData and StructuredData are not null before accessing their contents.

This update ensures that the Outputs object is documented accurately as a PluginContext type, reflecting its properties and usage in expressions. 

## Nested Access

Use dot notation and indexers:

| Example | Meaning |
| ------- | ------- |
| `$[Outputs('Extract').Id]` | Record's `Id`. |
| `$[Outputs('Transform').Content]` | Property traversal. |
| `$[Outputs('Task').Metadata[Variables('Index')]]` | Dynamic index. |

Arrays are supported for `IList` and `JArray`. Properties are resolved case-insensitively (`JObject`, `JToken`, or CLR objects).

## Literal Values

Inside expressions you can use:
- Quoted strings: `'text'` or `"text"`
- Numbers: `42`, `3.14`
- Booleans: `true`, `false`
- Null: `null`

Example: `$['static-value']`

## Functional Methods

Built-in case-insensitive aggregation and search functions:

| Function | Signature | Behavior |
| -------- | --------- | -------- |
| `Min` | `Min(arg1, arg2, collection, ...)` | Returns smallest numeric value (flattens enumerables). |
| `Max` | `Max(...)` | Returns largest numeric value. |
| `Sum` | `Sum(...)` | Sums all numeric values. |
| `Avg` | `Avg(...)` | Arithmetic mean (0 if no numbers). |
| `Count` | `Count(collection)` or `Count(arg1,arg2,...)` | If single enumerable → element count; otherwise number of arguments. |
| `Contains` | `Contains(container, value)` | Case-insensitive search (strings, enumerables, or direct value comparison). |

Arguments can be:
- Literals
- Variable/output references
- Nested expressions
- Other functional calls

Examples:

```
$[Sum(Variables('Prep').Values)] 
$[Avg(Variables('A').Numbers, Outputs('B').Content, 10)] 
$[Count(Variables('ListTask').Items)] 
$[Contains(Outputs('Meta').Metadata, 'critical')] 
$[Min(Variables('A').Values, Variables('B').Values)]
```

## Arithmetic Expressions

You can perform arithmetic inside `$[...]` using operators: `+ - * / %` and parentheses.

```
$[(Variables('Calc').Base + Variables('Offset')) * 0.5]
```

Resolution flow:
1. Embedded `$[...]` segments inside the arithmetic are first resolved.
2. `Variables(...)` / `Outputs(...)` inside arithmetic are replaced with their string value (missing values become `0` in arithmetic context).
3. Expression is evaluated; numeric result returned as `double`.
4. If evaluation fails, it falls back to literal/lookup interpretation.

## Boolean Logic & Comparisons

Supported operators: `== != > < >= <= && || !`

Examples:

```
$[Variables('Mode') == 'fast'] 
$[Variables('Stats').Errors > 0 && Variables('Stats').Warnings == 0] 
$[!Contains(Variables('Tags').All,'deprecated')]
```

Comparison semantics:
- Equality is case-insensitive string comparison for `==` / `!=`.
- Relational operators (`> < >= <=`) apply only if both sides convert to numbers.

## Conditional (Ternary) Expressions

```
$[Variables('Score').Value >= 90 ? 'excellent' : 'standard'] 
$[Contains(Outputs('Meta').Metadata, 'urgent') ? Variables('UrgentPath') : Variables('NormalPath')]
```

Format: `condition ? whenTrue : whenFalse`  
Condition can include logical or comparison operators.

## Recursive & Dynamic Keys

You can build dynamic keys or nested expressions:

```
$[Variables(Outputs('Meta').Id)] 
$[Outputs(Variables('DynamicTask')).StructuredData]
```

Resolution is recursive: inner expressions resolve before outer structures.

## String Concatenation Example

```
"Path": "$[Variables('Base')]/$[Outputs('Export').Id]"
```

If:

```
Variables: { "Base": "/data/out" } Outputs: { "Export": { "Id": "report.csv" } }
```

Result:

```
/data/out/report.csv
```

## Return Value Behavior

1. Whole expression only: `$[Outputs('Task')]` → returns the raw object (array, complex type, etc.).
2. Embedded in text: `"File=$[Outputs('Task').Id]"` → string interpolation.
3. Functions/Arithmetic: return numeric or boolean values directly if standalone.

## Error Handling

Parser throws `FlowSynxException` (code: `ExpressionParserKeyNotFound`) for:
- Missing `Variables('key')` or `Outputs('key')`.
- Unbalanced brackets `[...]` or parentheses `(...)`.
- Invalid functional syntax (e.g. `Contains()` with argument count ≠ 2).
- Malformed conditional expressions.

In arithmetic-only contexts, missing lookups are coerced to `0` (to avoid failure). Direct lookup outside arithmetic still throws.

## Examples

```
$[Sum(Outputs('Collect').Content, 10, Variables('Bonus'))] 
$[Outputs('Metrics').Metadata[0] > 50 ? 'pass' : 'fail'] 
$[Contains(Outputs('Tags').List, Variables('TargetTag')) && Variables('Stats').Count >= 5] 
$[Min(Outputs('A').Content, Outputs('B').Content)] 
$[Variables(Outputs('Resolver').Id)]
```


## Best Practices

- Use single quotes for keys with spaces: `$[Variables('My Key')]`.
- Keep arithmetic numeric; non-numeric tokens cause literal fallback.
- Prefer explicit parentheses for complex logic.
- Avoid over-nesting; consider storing intermediate values in variables.

## Summary

FlowSynx Expressions support:
- Dynamic access to variables and task outputs
- Nested property and array traversal
- Functional aggregation (Min/Max/Sum/Avg/Count/Contains)
- Arithmetic and numeric evaluation
- Boolean logic and conditional branching
- Recursive and dynamic key resolution
- Strong error signaling for invalid syntax

:::info
Expressions can be used in any string field in workflow definitions. Mix multiple `$[...]` segments freely; each is resolved independently and merged into the final string.
:::