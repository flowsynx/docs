"use strict";(globalThis.webpackChunkflowsynx=globalThis.webpackChunkflowsynx||[]).push([[778],{3211:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/source-agnostic-processing","title":"Source-Agnostic Processing","description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments.","source":"@site/docs/concepts/source-agnostic-processing.mdx","sourceDirName":"concepts","slug":"/concepts/source-agnostic-processing","permalink":"/docs/concepts/source-agnostic-processing","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1766591722000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},"sidebar":"docSidebar","previous":{"title":"Unified Data Abstraction Layer","permalink":"/docs/concepts/unified-data-abstraction-layer"},"next":{"title":"Trigger-Based Execution","permalink":"/docs/concepts/trigger-based-execution"}}');var o=s(4848),r=s(8453);const t={sidebar_position:6,description:"FlowSynx is fully container-ready, making it easy to deploy in isolated, reproducible environments using Docker. This option is highly recommended for users looking to minimize conflicts, simplify upgrades, and ensure consistent behavior across development, staging, and production environments."},a="Source-Agnostic Processing",l={},c=[{value:"A Universal Processing Model",id:"a-universal-processing-model",level:2},{value:"Benefits of Source-Agnostic Processing",id:"benefits-of-source-agnostic-processing",level:2},{value:"1. Uniformity Across All Plugins",id:"1-uniformity-across-all-plugins",level:3},{value:"2. High Reusability",id:"2-high-reusability",level:3},{value:"3. Extensibility for New Data Sources",id:"3-extensibility-for-new-data-sources",level:3},{value:"4. Platform and Cloud Neutrality",id:"4-platform-and-cloud-neutrality",level:3},{value:"5. Horizontal Scalability",id:"5-horizontal-scalability",level:3},{value:"How Source-Agnostic Processing Powers Complex Workflows",id:"how-source-agnostic-processing-powers-complex-workflows",level:2},{value:"A Future-Proof Processing Layer",id:"a-future-proof-processing-layer",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"source-agnostic-processing",children:"Source-Agnostic Processing"})}),"\n",(0,o.jsxs)(n.p,{children:["Source-agnostic processing is one of FlowSynx\u2019s most powerful architectural principles. It enables workflow authors to ingest\nand operate on data from virtually any system\u2014without requiring plugins or workflow logic to be aware of where that data\noriginally came from. This capability is made possible by FlowSynx\u2019s ",(0,o.jsx)(n.strong,{children:"Unified Data Abstraction Layer (UDAL)"}),", which normalizes\nand harmonizes data into a single, structured, internal representation."]}),"\n",(0,o.jsxs)(n.p,{children:["Once the data is mapped into the UDAL model, all downstream processing plugins\u2014such as ",(0,o.jsx)(n.code,{children:"CsvTransformer"}),", ",(0,o.jsx)(n.code,{children:"ZipCompressor"}),", ",(0,o.jsx)(n.code,{children:"ZipDecompressor"}),",\n",(0,o.jsx)(n.code,{children:"DatabaseWriter"}),", and custom domain-specific processors\u2014can operate uniformly and interchangeably. The workflow remains focused on the\n",(0,o.jsx)(n.em,{children:"business logic"}),", while UDAL eliminates the burden of source-specific parsing, formatting, and connection handling."]}),"\n",(0,o.jsx)(n.h2,{id:"a-universal-processing-model",children:"A Universal Processing Model"}),"\n",(0,o.jsx)(n.p,{children:"Data entering FlowSynx may originate from a wide variety of systems:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Local file systems"})," (CSV, JSON, XML, images, binaries)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cloud storage platforms"})," like Azure Blob Storage, Azure Data Lake, AWS S3, or Google Cloud Storage"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"REST APIs"}),", SOAP services, or custom HTTP endpoints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Databases"})," accessed through SQL queries or ORM adapters"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Message streaming platforms"})," such as Kafka, Azure Event Hub, or RabbitMQ"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Regardless of the protocol, format, or transport mechanism, FlowSynx transforms the incoming payload into a consistent UDAL object.\nThis makes subsequent processing steps entirely source-independent."}),"\n",(0,o.jsx)(n.p,{children:"For example, a plugin that enriches customer records does not need to care whether the input came from a CSV stored on-prem, a JSON\ndocument retrieved from S3, or an API response from a third-party service. With UDAL, it sees only structured records ready for transformation."}),"\n",(0,o.jsx)(n.h2,{id:"benefits-of-source-agnostic-processing",children:"Benefits of Source-Agnostic Processing"}),"\n",(0,o.jsx)(n.p,{children:"FlowSynx\u2019s unified data approach provides practical, high-impact advantages for real-world automation pipelines:"}),"\n",(0,o.jsx)(n.h3,{id:"1-uniformity-across-all-plugins",children:"1. Uniformity Across All Plugins"}),"\n",(0,o.jsx)(n.p,{children:"Every plugin speaks the same language\u2014the UDAL schema.\nThis reduces conditional code paths, eliminates source-driven edge cases, and ensures deterministic behavior across all environments and workflows."}),"\n",(0,o.jsx)(n.h3,{id:"2-high-reusability",children:"2. High Reusability"}),"\n",(0,o.jsx)(n.p,{children:"Transformations, validation rules, enrichment steps, and routing logic become portable.\nA single workflow component can be reused across multiple ingestion routes without modification."}),"\n",(0,o.jsx)(n.h3,{id:"3-extensibility-for-new-data-sources",children:"3. Extensibility for New Data Sources"}),"\n",(0,o.jsx)(n.p,{children:"Adding support for a new system (e.g., a new cloud provider or database type) requires only a new source adapter.\nExisting plugins, transformations, and workflow definitions continue working without changes."}),"\n",(0,o.jsx)(n.h3,{id:"4-platform-and-cloud-neutrality",children:"4. Platform and Cloud Neutrality"}),"\n",(0,o.jsx)(n.p,{children:"Organizations can migrate between storage systems or cloud providers without redesigning workflows.\nThis enables cost optimization, hybrid-cloud portability, and long-term architectural resilience."}),"\n",(0,o.jsx)(n.h3,{id:"5-horizontal-scalability",children:"5. Horizontal Scalability"}),"\n",(0,o.jsx)(n.p,{children:"Because processing logic is independent of storage or access patterns, FlowSynx workflows can scale across containers, nodes, or grid environments\nwith minimal configuration overhead."}),"\n",(0,o.jsx)(n.h2,{id:"how-source-agnostic-processing-powers-complex-workflows",children:"How Source-Agnostic Processing Powers Complex Workflows"}),"\n",(0,o.jsx)(n.p,{children:"Large enterprises often need to orchestrate multi-stage, multi-source workflows such as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Merging data from hybrid on-prem/cloud systems"}),"\n",(0,o.jsx)(n.li,{children:"Normalizing mixed structured and semi-structured datasets"}),"\n",(0,o.jsx)(n.li,{children:"Running scheduled ETL/ELT pipelines across distributed storage locations"}),"\n",(0,o.jsx)(n.li,{children:"Coordinating asynchronous streaming events with batch processes"}),"\n",(0,o.jsx)(n.li,{children:"Auditing or reconciling third-party API data with internal DB records"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"With UDAL at the core, FlowSynx allows all these operations to behave consistently\u2014no matter the underlying systems."}),"\n",(0,o.jsx)(n.p,{children:"Error handling, retries, branching, and data lineage tracing also benefit: since the processing model is uniform, debugging and monitoring remain\nsimple even when handling complex, heterogeneous data flows."}),"\n",(0,o.jsx)(n.h2,{id:"a-future-proof-processing-layer",children:"A Future-Proof Processing Layer"}),"\n",(0,o.jsx)(n.p,{children:"As enterprise data ecosystems evolve, FlowSynx\u2019s source-agnostic foundation ensures that workflows remain stable and maintainable.\nData source changes\u2014often the most disruptive part of workflow engineering\u2014become trivial to handle."}),"\n",(0,o.jsxs)(n.p,{children:["By separating ",(0,o.jsx)(n.em,{children:"how data is accessed from how data is processed"}),", FlowSynx empowers teams to build robust, scalable, vendor-neutral\nautomation pipelines that stand the test of time."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const o={},r=i.createContext(o);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);